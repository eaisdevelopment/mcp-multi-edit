---
phase: 07-multi-file-operations
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/tools/multi-edit-files.ts
  - src/core/reporter.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Claude client can call multi_edit_files and receive structured results (not NOT_IMPLEMENTED)"
    - "All files are edited successfully on success, or all remain unchanged on failure (cross-file atomicity)"
    - "If file 2 of 3 fails, file 1 is rolled back to its original content from .bak"
    - "Result includes per-file status with file_path, edits_applied, backup_path for each file"
    - "Result includes top-level summary with total_files, files_succeeded, files_failed, total_edits"
    - "Dry-run mode previews all files without writing, includes diff previews"
    - "Backup parameter is ignored for multi-file (always true) because backups are the rollback mechanism"
    - "include_content applies to all files when set"
  artifacts:
    - path: "src/tools/multi-edit-files.ts"
      provides: "Complete 3-phase multi-file handler with rollback"
      exports: ["handleMultiEditFiles"]
    - path: "src/core/reporter.ts"
      provides: "Enhanced multi-file response formatting"
      exports: ["formatMultiEditFilesResponse"]
    - path: "src/index.ts"
      provides: "Wired multi_edit_files handler (no longer NOT_IMPLEMENTED)"
      contains: "handleMultiEditFiles"
  key_links:
    - from: "src/index.ts"
      to: "src/tools/multi-edit-files.ts"
      via: "import and route to handleMultiEditFiles"
      pattern: "handleMultiEditFiles"
    - from: "src/tools/multi-edit-files.ts"
      to: "src/core/validator.ts"
      via: "validateMultiEditFilesInputFull call"
      pattern: "validateMultiEditFilesInputFull"
    - from: "src/tools/multi-edit-files.ts"
      to: "src/core/editor.ts"
      via: "readFileValidated, applyEditsToContent, atomicWrite, createBackup"
      pattern: "applyEditsToContent"
---

<objective>
Implement the complete multi-file handler with 3-phase pipeline (validate-all, backup-edit, rollback) and wire it into the MCP server.

Purpose: This is the core of Phase 7 — making `multi_edit_files` work with true cross-file atomicity. The handler uses validation from Plan 07-01, implements backup-based rollback, and produces detailed per-file results with top-level summary. The handler is wired into `index.ts` replacing the NOT_IMPLEMENTED stub.

Output: Fully functional `handleMultiEditFiles()` in `src/tools/multi-edit-files.ts`, enhanced reporter in `src/core/reporter.ts`, and wired routing in `src/index.ts`.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-file-operations/07-CONTEXT.md
@.planning/phases/07-multi-file-operations/07-RESEARCH.md
@.planning/phases/07-multi-file-operations/07-01-SUMMARY.md
@src/tools/multi-edit-files.ts
@src/tools/multi-edit.ts
@src/core/editor.ts
@src/core/reporter.ts
@src/core/errors.ts
@src/types/index.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite multi-edit-files handler with 3-phase pipeline and rollback</name>
  <files>src/tools/multi-edit-files.ts, src/core/reporter.ts</files>
  <action>
**Rewrite `src/tools/multi-edit-files.ts` with the 3-phase pipeline:**

The handler must implement these three phases:

**Phase A — Validate All Upfront:**
1. Call `validateMultiEditFilesInputFull(args)` (from Plan 07-01).
2. If validation fails, return ErrorEnvelope with error_code `'VALIDATION_FAILED'`, message describing error count, and `recovery_hints` built from all validation errors. Set `isError: true`.
3. If validation passes, extract the validated input (with resolved file paths).

**Phase B — Backup + Edit (fail-fast):**

Per CONTEXT decision: `backup` param is IGNORED for multi-file — always create backups (they are the rollback mechanism).

For each file in array order:
1. `readFileValidated(file.file_path)` — read file content (UTF-8 validated)
2. `createBackup(file.file_path, content)` — mandatory backup
3. `applyEditsToContent(file.file_path, content, file.edits, dry_run)` — apply edits in memory
4. If `applyEditsToContent` returns `success: false` → trigger Phase C rollback for all previously written files, return error response
5. If NOT dry_run: `atomicWrite(file.file_path, result.final_content!)` — write to disk
6. Track: add file to `writtenFiles` list (file_path + backup_path) and store its `MultiEditResult`

If a file read, backup, or write throws an exception → same as edit failure: trigger Phase C.

**Phase C — Rollback (on failure only):**

Implement a `rollbackFiles(writtenFiles)` helper function:
1. Iterate `writtenFiles` in REVERSE order
2. For each file: read its `.bak` file with `readFileValidated()`, then overwrite the original with `atomicWrite()`
3. If rollback for a file succeeds: record `{ file_path, status: 'restored', backup_path }`
4. If rollback for a file fails: record `{ file_path, status: 'failed', backup_path, error: message }`, continue with remaining files
5. Return a `RollbackReport` (from types)

**Error response on edit failure (after rollback):**

Build an ErrorEnvelope with:
- `error_code`: classified from the failure (use `classifyError` or `classifyErrorCodeFromMessage`)
- `message`: `"Edit failed in file {N} of {total}: {error}"`
- `file_path`: the failed file's path
- `retryable`: per error code
- `recovery_hints`: per error code
- Attach `rollback` report if any files were rolled back

Additionally, build a per-file status array for the response with statuses: `'succeeded'` (written then rolled back), `'failed'` (the file that errored), `'skipped'` (files not yet processed). This goes in the response text alongside the envelope.

**Success response:**

Build a `MultiEditFilesResult` with:
- `success: true`
- `files_edited`: count of files
- `file_results`: array of per-file `MultiEditResult` (each has file_path, edits_applied, results, backup_path, dry_run)
- `summary`: `{ total_files, files_succeeded, files_failed: 0, total_edits }` where total_edits = sum of all edits_applied across files
- `dry_run`: the dry_run flag

If `include_content` is true, keep `final_content` on each per-file result. If false, strip `final_content` from each result before responding.

For dry-run: still create backups (consistent with single-file), still apply edits in memory, but skip `atomicWrite()`. Generate diff previews per file using `generateDiffPreview()` from reporter.ts. Attach `message: 'DRY RUN - No changes made'` and `diff_preview` per file.

Format the success response using a new `formatMultiEditFilesResponse()` function (see reporter task below).

**In `src/core/reporter.ts`:**

Add a new exported function `formatMultiEditFilesResponse()` that takes a `MultiEditFilesResult` and optional `includeContent: boolean` and formats it as JSON string. This should:
1. If `includeContent` is false, strip `final_content` from each `file_results` entry before serializing
2. Return `JSON.stringify(result, null, 2)`

Also update `createFilesSuccessResult()` to accept and populate the `summary` field:
```typescript
export function createFilesSuccessResult(
  fileResults: MultiEditResult[],
  dryRun: boolean
): MultiEditFilesResult {
  const filesSucceeded = fileResults.filter(r => r.success).length;
  const totalEdits = fileResults.reduce((sum, r) => sum + r.edits_applied, 0);
  return {
    success: true,
    files_edited: fileResults.length,
    file_results: fileResults,
    summary: {
      total_files: fileResults.length,
      files_succeeded: filesSucceeded,
      files_failed: fileResults.length - filesSucceeded,
      total_edits: totalEdits,
    },
    dry_run: dryRun,
  };
}
```

Keep the existing `classifyErrorCodeFromMessage` helper in multi-edit-files.ts (it's still useful for classifying per-file edit errors from result.error strings).
  </action>
  <verify>Run `npm run build` — TypeScript compilation succeeds with no errors.</verify>
  <done>Handler implements 3-phase pipeline: validate-all upfront, backup+edit with fail-fast, rollback on failure. Backups are always created (backup param ignored). Rollback restores from .bak files in reverse order. Success response includes per-file results and top-level summary. Dry-run creates backups and simulates edits without writing. include_content controls final_content inclusion.</done>
</task>

<task type="auto">
  <name>Task 2: Wire handler in index.ts and update tool schema</name>
  <files>src/index.ts</files>
  <action>
In `src/index.ts`:

1. **Uncomment the import** on line 17-18:
   - Remove: `// TODO: Import multi_edit_files handler when implemented`
   - Remove: `// import { handleMultiEditFiles } from './tools/multi-edit-files.js';`
   - Add: `import { handleMultiEditFiles } from './tools/multi-edit-files.js';`

2. **Replace the NOT_IMPLEMENTED stub** in the `CallToolRequestSchema` handler:
   - Remove the entire `if (name === 'multi_edit_files')` block that returns NOT_IMPLEMENTED
   - Replace with: `if (name === 'multi_edit_files') { return await handleMultiEditFiles(args); }`

3. **Add `include_content` to the multi_edit_files tool schema** in the TOOLS array:
   Add after the `backup` property:
   ```typescript
   include_content: {
     type: 'boolean',
     description: 'Include final file content in response (default: false, use for verification)',
   },
   ```

4. **Update the `backup` property description** to note it's ignored for multi-file:
   Change the description to: `'Ignored for multi-file operations (backups are always created as rollback mechanism). For single-file use multi_edit instead.'`

This is a small wiring task — the handler does all the work.
  </action>
  <verify>Run `npm run build` — succeeds. Verify routing: `grep -n "handleMultiEditFiles\|NOT_IMPLEMENTED" src/index.ts` should show handleMultiEditFiles import and call, no NOT_IMPLEMENTED for multi_edit_files.</verify>
  <done>multi_edit_files routes to handleMultiEditFiles. NOT_IMPLEMENTED stub is gone. Tool schema includes include_content. Import is uncommented and active. Build passes.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero TypeScript errors
2. `grep -n "NOT_IMPLEMENTED" src/index.ts` returns zero matches related to multi_edit_files
3. `grep -n "handleMultiEditFiles" src/index.ts` shows import and route
4. `src/tools/multi-edit-files.ts` imports `validateMultiEditFilesInputFull`
5. `src/tools/multi-edit-files.ts` contains rollback logic (search for "rollback" or "RollbackReport")
6. `src/core/reporter.ts` exports `formatMultiEditFilesResponse`
7. `src/core/reporter.ts` `createFilesSuccessResult` populates `summary` field
</verification>

<success_criteria>
- multi_edit_files tool is functional (routed, not stubbed)
- Handler validates all files upfront before any edits
- Handler creates mandatory backups for every file
- Handler rolls back on failure using .bak files in reverse order
- Success response includes per-file results and top-level summary
- Dry-run works for multi-file with diff previews
- include_content controls final_content in response
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-file-operations/07-02-SUMMARY.md`
</output>
