---
phase: 10-coverage-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/tool-error-paths.test.ts
autonomous: true

must_haves:
  truths:
    - "multi-edit-files.ts error paths (read failure, backup failure, write failure, unexpected exception, rollback failure) all have tests"
    - "multi-edit.ts catch block (L63-74) is exercised by a test"
    - "server.ts catch block (L164-173) is exercised by a test"
    - "multi-edit-files.ts coverage rises from 62% to 85%+"
    - "multi-edit.ts coverage rises from 85% to 95%+"
    - "server.ts coverage rises from 94% to 98%+"
  artifacts:
    - path: "tests/unit/tool-error-paths.test.ts"
      provides: "Error path tests for both tool handlers and server catch block"
      min_lines: 150
  key_links:
    - from: "tests/unit/tool-error-paths.test.ts"
      to: "src/tools/multi-edit-files.ts"
      via: "direct import + vi.spyOn mocking"
      pattern: "import.*handleMultiEditFiles"
    - from: "tests/unit/tool-error-paths.test.ts"
      to: "src/tools/multi-edit.ts"
      via: "direct import + vi.spyOn mocking"
      pattern: "import.*handleMultiEdit"
    - from: "tests/unit/tool-error-paths.test.ts"
      to: "src/server.ts"
      via: "direct import + vi.spyOn mocking"
      pattern: "import.*createServer"
---

<objective>
Test error and rollback paths in multi-edit-files.ts, multi-edit.ts, and server.ts handlers.

Purpose: multi-edit-files.ts has the largest single-file coverage gap (62%) because its error/rollback paths require filesystem failures that don't happen in normal testing. The multi-edit.ts catch block and server.ts catch block are small but need exercising for coverage.

Output: One new test file covering all tool-handler error paths using vi.spyOn to trigger filesystem errors on real temp files.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-coverage-completion/10-RESEARCH.md
@src/tools/multi-edit-files.ts
@src/tools/multi-edit.ts
@src/server.ts
@src/core/editor.ts
@src/core/errors.ts
@src/types/index.ts
@tests/integration/server.test.ts
@tests/unit/editor-io.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test multi-edit-files.ts error and rollback paths</name>
  <files>tests/unit/tool-error-paths.test.ts</files>
  <action>
Create tests/unit/tool-error-paths.test.ts.

**Setup pattern:** Use real temp files (like edge-cases.test.ts does) for valid inputs that pass validation, then use `vi.spyOn` on imported editor functions to make specific operations fail at the right moment.

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { handleMultiEditFiles } from '../../src/tools/multi-edit-files.js';
import { handleMultiEdit } from '../../src/tools/multi-edit.js';
import * as editor from '../../src/core/editor.js';
import { mkdtemp, writeFile, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { realpathSync } from 'node:fs';
```

Use `beforeEach` to create a temp dir and test files. Use `afterEach` to clean up temp dir and restore all mocks (`vi.restoreAllMocks()`).

**Important:** The temp dir must be created with `realpathSync(await mkdtemp(...))` to handle macOS /tmp -> /private/tmp symlink (per 09-01 decision).

Helper to parse tool result: `const parse = (r: any) => JSON.parse(r.content[0].text);`

**multi-edit-files.ts error path tests** (describe block: 'handleMultiEditFiles error paths'):

1. **Read failure on file 2 of 3 (with rollback of file 1)**:
   - Create 3 real test files (file1.txt, file2.txt, file3.txt)
   - Spy on `editor.readFileValidated`: let first call through, then reject on second call with ENOENT error
   - Call handleMultiEditFiles with valid edits for all 3 files
   - Expect: isError=true, error_code='FILE_NOT_FOUND', rollback report present, file_statuses showing file1 rolled_back, file2 failed, file3 skipped
   - Implementation: `vi.spyOn(editor, 'readFileValidated').mockImplementation(async (path) => { if (path.includes('file2')) throw Object.assign(new Error('ENOENT'), { code: 'ENOENT' }); return originalImpl(path); })` -- or use `mockResolvedValueOnce` for first call then `mockRejectedValueOnce` for second.
   - Actually, since readFileValidated is called for reading AND for rollback, be careful. A simpler approach: create file1 and file3 with content but make file2 trigger a read error. Use the spy to intercept only the file2 read.

2. **Backup failure on file 1**:
   - Create 1 real test file
   - Spy on `editor.createBackup` to reject with 'EACCES' error
   - Call handleMultiEditFiles with valid edit for 1 file
   - Expect: isError=true, error_code='BACKUP_FAILED', no rollback (nothing written yet)

3. **Write failure (atomicWrite throws) on file 2 after file 1 succeeds**:
   - Create 2 real test files
   - Track atomicWrite calls: let first call through, throw on second
   - Spy on `editor.atomicWrite`: use counter or path matching. First call succeeds (file1 written), second call throws ENOSPC.
   - Call handleMultiEditFiles with valid edits for both files
   - Expect: isError=true, error_code='DISK_FULL', rollback report with file1 restored

4. **Unexpected exception in outer try/catch (L283-305)**:
   - Spy on `editor.applyEditsToContent` to throw a non-filesystem Error (e.g., `new TypeError('unexpected')`)
   - Note: applyEditsToContent is a synchronous function, so use `mockImplementation` that throws (not mockRejectedValue)
   - Call handleMultiEditFiles with valid input
   - Expect: isError=true, error_code='UNKNOWN_ERROR'

5. **Rollback failure (readFileValidated fails during rollback)**:
   - This tests the catch block inside rollbackFiles (L77-81)
   - Create 2 test files. Spy so that: readFileValidated succeeds for initial reads, atomicWrite succeeds for file1, atomicWrite throws for file2. Then during rollback, readFileValidated for the backup file also throws.
   - This is complex. Simplest approach: after the write of file1, manually delete the .bak file before file2's write fails, so rollback can't find the backup.
   - Alternative: spy on readFileValidated to throw only when reading .bak paths.
   - Expect: response has rollback.files_failed_rollback > 0, rollback details show 'failed' status

6. **buildFileStatuses with skipped files (L351-356)**:
   - This is tested as part of test 1 (file3 is skipped). Verify file_statuses[2].status === 'skipped'.

7. **classifyErrorCodeFromMessage branches (L32-52)**:
   - These are tested indirectly through the error path tests above. Ensure at least these message patterns are triggered:
   - 'not found' (test 1 covers this)
   - 'matches at lines' or 'occurrences found': trigger by having an applyEditsToContent return a result with an ambiguous match error. Create a file with duplicate content and use an edit that matches multiple times without replace_all.
   - 'permission denied' or 'eacces': covered by backup failure error message propagation
   - 'encoding': create a test where applyEditsToContent result has an encoding-related error
   - 'backup failed': covered by test 2

**Note on mocking strategy:** Import `* as editor` to get a mutable namespace object. Use `vi.spyOn(editor, 'functionName')` for individual function spying. The editor module uses named exports, so this works directly (unlike validator which uses default export -- per 08-02 decision). For functions like `readFileValidated`, you may need to save the original: `const originalRead = editor.readFileValidated;` before spying.
  </action>
  <verify>
Run `npx vitest run tests/unit/tool-error-paths.test.ts` -- all tests pass.
Run `npx vitest run --coverage` and check multi-edit-files.ts coverage improved significantly from 62%.
  </verify>
  <done>
multi-edit-files.ts has tests for read failure, backup failure, write failure, unexpected exception, and rollback failure paths.
classifyErrorCodeFromMessage branches are exercised.
buildFileStatuses skipped-files branch is exercised.
multi-edit-files.ts coverage is 85%+ on lines.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test multi-edit.ts catch block and server.ts catch block</name>
  <files>tests/unit/tool-error-paths.test.ts</files>
  <action>
Add to the same tests/unit/tool-error-paths.test.ts file (append new describe blocks).

**multi-edit.ts catch block (L63-74)** (describe block: 'handleMultiEdit error paths'):

1. **applyEdits throws unexpected error**:
   - Create a real test file with content 'hello world'
   - Spy on `editor.applyEdits` to reject with `new Error('unexpected kaboom')`
   - Note: `applyEdits` is imported in multi-edit.ts from `../core/editor.js`. Spy via `vi.spyOn(editor, 'applyEdits')`.
   - Wait -- handleMultiEdit imports applyEdits from its own import, not from our `editor` reference. We need to mock the module that handleMultiEdit imports.
   - Better approach: use `vi.mock` at the top of the file for `../../src/core/editor.js` with `vi.fn()` wrappers, and use `vi.mocked()` to control behavior per test. BUT this would affect multi-edit-files.ts tests too.
   - Cleanest approach: Don't mock the module globally. Instead, spy on the specific function. Since multi-edit.ts does `import { applyEdits } from '../core/editor.js'`, and we import `* as editor from '../../src/core/editor.js'`, spying on `editor.applyEdits` WILL affect the bound reference IF the module is ESM with live bindings. In Vitest with ESM interop, `vi.spyOn` on the namespace object does work for named exports.
   - Call `handleMultiEdit({ file_path: testFilePath, edits: [{ old_string: 'hello', new_string: 'goodbye' }] })`
   - Expect: isError=true, parsed content has error_code='UNKNOWN_ERROR', message contains 'unexpected kaboom'

2. **applyEdits throws EACCES error**:
   - Same setup but throw `Object.assign(new Error('permission denied'), { code: 'EACCES' })`
   - Expect: error_code='PERMISSION_DENIED'

**server.ts catch block (L164-173)** (describe block: 'server.ts handler catch block'):

The catch block in server.ts wraps the entire `handleMultiEdit`/`handleMultiEditFiles` calls. To trigger it, we need one of those handlers to throw (not return an error -- actually throw an uncaught exception).

1. **Handler throws uncaught exception**:
   - Import `createServer` from `../../src/server.ts`
   - Import `Client` from `@modelcontextprotocol/sdk/client/index.js`
   - Import `InMemoryTransport` from `@modelcontextprotocol/sdk/inMemory.js`
   - Create server and client using InMemoryTransport (same pattern as server.test.ts)
   - Spy on `handleMultiEdit` (imported from multi-edit.ts): `vi.spyOn` won't work across module boundaries for this. Instead, since server.ts imports handleMultiEdit, the best approach is: mock the entire `../../src/tools/multi-edit.js` module so that `handleMultiEdit` throws.
   - Use: `vi.mock('../../src/tools/multi-edit.js', () => ({ handleMultiEdit: vi.fn() }))` at top of file (or in a describe block with vi.hoisted).
   - Actually, the simplest approach that avoids interfering with other tests: **Do NOT test server.ts catch via MCP client.** Instead, recognize that this catch block is a defensive safety net. If it's genuinely hard to trigger cleanly without disrupting other tests, use `/* v8 ignore next */` annotation in Plan 03 for these ~10 lines. The server.ts is already at 94%.
   - **Revised approach:** Try a focused test. Create a NEW test file or a separate describe block that mocks only for this specific test. Use `vi.doMock` (not `vi.mock`) for dynamic scoped mocking:

   ```typescript
   describe('server.ts handler catch block', () => {
     it('should catch handler exceptions and return ErrorEnvelope', async () => {
       // Dynamically mock multi-edit to throw
       vi.doMock('../../src/tools/multi-edit.js', () => ({
         handleMultiEdit: vi.fn().mockRejectedValue(new Error('handler exploded')),
       }));

       // Re-import server to pick up the mock
       const { createServer } = await import('../../src/server.js');
       // ... create client, call tool, verify ErrorEnvelope response
     });
   });
   ```

   However, `vi.doMock` with `await import()` can be tricky. If this proves fragile, fall back to the v8 ignore approach in Plan 03.

   - Call `client.callTool({ name: 'multi_edit', arguments: { file_path: '/tmp/test.txt', edits: [{ old_string: 'a', new_string: 'b' }] } })`
   - Expect: response content has error_code, message contains 'handler exploded'

**If the server.ts catch test is too fragile with module mocking**, skip it and document it as a candidate for `/* v8 ignore */` in Plan 03. server.ts is already at 94% and the catch block is purely defensive.
  </action>
  <verify>
Run `npx vitest run tests/unit/tool-error-paths.test.ts` -- all tests pass.
Run `npx vitest run --coverage` and check multi-edit.ts coverage improved from 85% to 95%+.
  </verify>
  <done>
multi-edit.ts catch block is tested (coverage 95%+).
server.ts catch block is either tested or documented for v8 ignore in Plan 03.
All tool handler error paths have test coverage.
  </done>
</task>

</tasks>

<verification>
After both tasks:
- `npx vitest run` -- all tests pass (existing + new)
- `npx vitest run --coverage` confirms:
  - multi-edit-files.ts: 62% -> 85%+ lines
  - multi-edit.ts: 85% -> 95%+ lines
  - server.ts: 94% -> 98%+ lines (or documented for v8 ignore)
</verification>

<success_criteria>
- multi-edit-files.ts error/rollback paths all tested (read, backup, write failures + rollback + skipped files)
- multi-edit.ts catch block exercised
- server.ts catch block exercised or documented for v8 ignore
- ~10-15 new test cases in tool-error-paths.test.ts
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-coverage-completion/10-02-SUMMARY.md`
</output>
