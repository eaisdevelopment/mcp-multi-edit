---
phase: 01-core-editor-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/core/editor.ts
  - src/types/index.ts
  - tests/unit/editor.test.ts
autonomous: true

must_haves:
  truths:
    - "applyEdits returns success result when all edits succeed"
    - "applyEdits returns error when old_string not found in file"
    - "applyEdits returns error with line numbers when old_string has multiple matches (replace_all=false)"
    - "applyEdits applies edits sequentially in array order"
    - "applyEdits allows replace_all flag to replace all occurrences"
    - "applyEdits allows no-op edits (old_string === new_string)"
  artifacts:
    - path: "src/core/editor.ts"
      provides: "applyEdits function with sequential simulation"
      exports: ["applyEdits", "findOccurrences", "replaceString"]
    - path: "src/types/index.ts"
      provides: "case_insensitive flag on EditOperation"
      contains: "case_insensitive"
    - path: "tests/unit/editor.test.ts"
      provides: "Tests for applyEdits function"
      contains: "describe('applyEdits'"
  key_links:
    - from: "src/core/editor.ts"
      to: "src/core/reporter.ts"
      via: "createSuccessResult, createErrorResult imports"
      pattern: "import.*from.*reporter"
    - from: "src/core/editor.ts"
      to: "src/types/index.ts"
      via: "type imports"
      pattern: "import.*EditOperation.*from.*types"
---

<objective>
Implement the core `applyEdits` function using TDD to ensure all edit operations work correctly with atomic guarantees.

Purpose: This is the heart of the multi-edit system - the function that applies multiple string replacements to file content with proper error handling and sequential simulation for atomicity.

Output: Working `applyEdits` function with comprehensive test coverage proving all edit behaviors work as specified in CONTEXT.md.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-editor-engine/01-CONTEXT.md
@.planning/phases/01-core-editor-engine/01-RESEARCH.md

Source files to modify:
@src/core/editor.ts
@src/types/index.ts
@tests/unit/editor.test.ts

Supporting files (read-only context):
@src/core/reporter.ts
@src/core/validator.ts
</context>

<feature>
  <name>applyEdits Core Implementation</name>
  <files>src/core/editor.ts, src/types/index.ts, tests/unit/editor.test.ts</files>
  <behavior>
    The applyEdits function applies multiple edit operations to in-memory content using sequential simulation.

    **Input/Output Contract:**
    - Input: filePath (string), edits (EditOperation[]), dryRun (boolean), createBackup (boolean)
    - Output: MultiEditResult with success/failure status and edit results

    **Test Cases (RED phase):**

    1. Empty edits array returns success with empty results
       - Input: content="hello", edits=[]
       - Expected: success=true, edits_applied=0, results=[]

    2. Single edit - successful replacement
       - Input: content="hello world", edits=[{old_string:"world", new_string:"there"}]
       - Expected: success=true, edits_applied=1, results[0].replaced=1

    3. Single edit - old_string not found (error)
       - Input: content="hello world", edits=[{old_string:"xyz", new_string:"abc"}]
       - Expected: success=false, error contains "not found", failed_edit_index=0

    4. Single edit - non-unique match without replace_all (error)
       - Input: content="foo bar foo", edits=[{old_string:"foo", new_string:"baz"}]
       - Expected: success=false, error contains "Found 2 matches at lines", failed_edit_index=0

    5. Single edit - replace_all succeeds with multiple matches
       - Input: content="foo bar foo", edits=[{old_string:"foo", new_string:"baz", replace_all:true}]
       - Expected: success=true, results[0].replaced=2

    6. Sequential edits - later edits see results of earlier
       - Input: content="hello world", edits=[{old_string:"world", new_string:"there"}, {old_string:"there", new_string:"you"}]
       - Expected: success=true, final content="hello you"

    7. No-op edit - old_string equals new_string allowed
       - Input: content="hello", edits=[{old_string:"hello", new_string:"hello"}]
       - Expected: success=true, results[0].replaced=0

    8. Sequential edits - first failure stops processing
       - Input: content="hello", edits=[{old_string:"xyz", new_string:"a"}, {old_string:"hello", new_string:"b"}]
       - Expected: success=false, failed_edit_index=0, edits_applied=0

    9. Line number reporting for non-unique errors
       - Input: content="foo\nbar\nfoo", edits=[{old_string:"foo", new_string:"x"}]
       - Expected: error contains "lines 1, 3"

    10. Case-insensitive matching (requires type update)
        - Input: content="Hello World", edits=[{old_string:"hello", new_string:"hi", case_insensitive:true}]
        - Expected: success=true, results[0].replaced=1
  </behavior>
  <implementation>
    **Implementation Strategy (GREEN phase):**

    1. **Add case_insensitive to EditOperation type** in src/types/index.ts:
       ```typescript
       case_insensitive?: boolean;
       ```

    2. **Add helper functions** to src/core/editor.ts:
       - `getLineNumber(content: string, charIndex: number): number` - convert char index to line number
       - `findAllMatchPositions(content: string, searchString: string, caseInsensitive: boolean): number[]` - find all match positions
       - `getMatchLineNumbers(content: string, searchString: string, caseInsensitive: boolean): number[]` - get line numbers of matches

    3. **Implement validateEdit function** in src/core/editor.ts:
       - Check for no-op (old_string === new_string) - return success with replaced=0
       - Count occurrences (case-sensitive or case-insensitive based on flag)
       - Zero matches -> return error with suggestion
       - Multiple matches without replace_all -> return error with line numbers
       - Otherwise -> return success

    4. **Implement applyEdits function** in src/core/editor.ts:
       - Handle empty edits array (return success)
       - Sequential simulation loop:
         - For each edit, validate against current simulated content
         - If validation fails, return error result immediately
         - Apply edit to simulated content for next iteration
         - Track results for each edit
       - After all validations pass, return success result
       - Note: Actual file I/O is handled in Plan 02 (atomic write)

    **Key implementation details from CONTEXT.md:**
    - Byte-exact matching (no normalization)
    - Zero matches is an error even with replace_all=true
    - Error format: "Edit N of M failed: ..."
    - Line numbers only for non-unique errors (not context snippets)
    - Allow no-op edits silently
  </implementation>
</feature>

<verification>
Run all tests:
```bash
npm test
```

Expected: All tests pass including new applyEdits tests.

Verify specific test file:
```bash
npm test -- tests/unit/editor.test.ts
```

Check test output shows:
- All 10 new test cases passing
- Existing findOccurrences and replaceString tests still passing
</verification>

<success_criteria>
1. All TDD test cases from the behavior section pass
2. applyEdits correctly validates all edits upfront via sequential simulation
3. Error messages include edit index ("Edit N of M failed")
4. Non-unique match errors include line numbers
5. case_insensitive flag works for matching
6. No-op edits allowed (old_string === new_string)
7. Existing utility function tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-editor-engine/01-01-SUMMARY.md`
</output>
