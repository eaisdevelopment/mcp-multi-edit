---
phase: 01-core-editor-engine
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/core/editor.ts
  - tests/unit/editor.test.ts
autonomous: true

must_haves:
  truths:
    - "applyEdits reads file from disk and validates UTF-8 encoding"
    - "applyEdits writes file atomically using temp-file-then-rename pattern"
    - "applyEdits returns error with recovery hint for file not found"
    - "applyEdits returns error for invalid UTF-8 encoding"
    - "File is never left in partial state after any operation"
    - "Temp files are cleaned up on failure"
  artifacts:
    - path: "src/core/editor.ts"
      provides: "Complete applyEdits with file I/O and atomic write"
      exports: ["applyEdits", "atomicWrite", "readFileValidated"]
    - path: "tests/unit/editor.test.ts"
      provides: "Tests for file I/O operations"
      contains: "describe('applyEdits file I/O'"
  key_links:
    - from: "src/core/editor.ts"
      to: "fs/promises"
      via: "Node.js file system operations"
      pattern: "import.*from 'fs/promises'"
    - from: "src/core/editor.ts"
      to: "os.tmpdir or same-directory temp"
      via: "temp file for atomic write"
      pattern: "path\\.join.*\\.tmp"
---

<objective>
Add file I/O capabilities to applyEdits with atomic write guarantees and proper error handling.

Purpose: Complete the applyEdits function by adding the ability to read files from disk, validate UTF-8 encoding, and write results atomically using the temp-file-then-rename pattern. This ensures files are never left in a partial state.

Output: Fully functional applyEdits that can read files, apply edits, and write results atomically with comprehensive test coverage for file I/O scenarios.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-editor-engine/01-CONTEXT.md
@.planning/phases/01-core-editor-engine/01-RESEARCH.md
@.planning/phases/01-core-editor-engine/01-01-SUMMARY.md

Source files to modify:
@src/core/editor.ts
@tests/unit/editor.test.ts
</context>

<feature>
  <name>Atomic File I/O for applyEdits</name>
  <files>src/core/editor.ts, tests/unit/editor.test.ts</files>
  <behavior>
    Complete applyEdits with file reading, UTF-8 validation, and atomic writing.

    **Test Cases (RED phase):**

    1. Read file and apply edits successfully
       - Setup: Create temp file with "hello world"
       - Input: filePath=temp file, edits=[{old_string:"world", new_string:"there"}]
       - Expected: success=true, file content is "hello there"

    2. File not found returns error with recovery hint
       - Input: filePath="/nonexistent/path.txt", edits=[...]
       - Expected: success=false, error contains "File not found", error contains "Check that file exists"

    3. Invalid UTF-8 returns clear error
       - Setup: Create temp file with invalid UTF-8 bytes
       - Input: filePath=temp file, edits=[...]
       - Expected: success=false, error contains "invalid UTF-8"

    4. Atomic write - file unchanged on validation failure
       - Setup: Create temp file with "hello"
       - Input: edits=[{old_string:"xyz", new_string:"abc"}] (will fail)
       - Expected: success=false, original file unchanged ("hello")

    5. Dry run mode - file unchanged
       - Setup: Create temp file with "hello world"
       - Input: dryRun=true, edits=[{old_string:"world", new_string:"there"}]
       - Expected: success=true, dry_run=true, file unchanged ("hello world")

    6. Temp file cleanup on error
       - Setup: Create temp file, mock write failure
       - Expected: No .tmp files left in directory after error

    7. Atomic write uses same directory (same filesystem)
       - Setup: Create temp file
       - During write: temp file should be in same directory as target
       - Expected: No EXDEV errors (cross-device rename)

    8. Permission error returns clear message
       - Setup: Create read-only directory
       - Input: filePath in read-only directory
       - Expected: error contains "permission" or specific recovery hint
  </behavior>
  <implementation>
    **Implementation Strategy (GREEN phase):**

    1. **Add readFileValidated helper** to src/core/editor.ts:
       ```typescript
       import { isUtf8 } from 'buffer';

       async function readFileValidated(filePath: string): Promise<string> {
         const buffer = await fs.readFile(filePath);
         if (!isUtf8(buffer)) {
           throw new Error(`File contains invalid UTF-8 encoding: ${filePath}. Ensure the file is UTF-8 encoded.`);
         }
         return buffer.toString('utf8');
       }
       ```

    2. **Add atomicWrite helper** to src/core/editor.ts:
       ```typescript
       import * as path from 'path';
       import * as crypto from 'crypto';

       async function atomicWrite(filePath: string, content: string): Promise<void> {
         const dir = path.dirname(filePath);
         const tempSuffix = crypto.randomBytes(6).toString('hex');
         const tempPath = path.join(dir, `.${path.basename(filePath)}.${tempSuffix}.tmp`);

         try {
           await fs.writeFile(tempPath, content, 'utf8');
           await fs.rename(tempPath, filePath);
         } catch (error) {
           try { await fs.unlink(tempPath); } catch { /* ignore cleanup errors */ }
           throw error;
         }
       }
       ```

    3. **Add formatFileError helper** for user-friendly messages:
       ```typescript
       function formatFileError(error: unknown, filePath: string): string {
         if (error instanceof Error) {
           if (error.message.includes('ENOENT')) {
             return `File not found: ${filePath}. Check that file exists.`;
           }
           if (error.message.includes('EACCES') || error.message.includes('EPERM')) {
             return `Permission denied: ${filePath}. Check file permissions.`;
           }
           return `File error: ${error.message}`;
         }
         return `Unknown file error: ${filePath}`;
       }
       ```

    4. **Update applyEdits** to integrate file I/O:
       - Try to read file with readFileValidated
       - On read error, return error result using formatFileError
       - Run sequential simulation (from Plan 01)
       - If dryRun, return success without writing
       - Write atomically using atomicWrite
       - On write error, return error result

    **Key implementation details from RESEARCH.md:**
    - Temp file in same directory as target (avoids EXDEV)
    - Use crypto.randomBytes for unique temp file names
    - Always clean up temp file on failure
    - isUtf8() from buffer module for validation
  </implementation>
</feature>

<verification>
Run all tests (requires temp file fixtures):
```bash
npm test
```

Expected: All tests pass including new file I/O tests.

Manual verification of atomic write:
```bash
# Create test file
echo "hello world" > /tmp/test-atomic.txt

# Run a failing edit and verify file unchanged
# (via integration test or manual CLI test)
```

Check for temp file leaks:
```bash
# After running tests, verify no .tmp files remain
ls -la /tmp/*.tmp 2>/dev/null || echo "No temp files (good)"
```
</verification>

<success_criteria>
1. applyEdits reads files from disk successfully
2. Invalid UTF-8 files return clear error message
3. File not found returns error with recovery hint
4. Atomic write uses temp-file-then-rename pattern
5. Temp files are always cleaned up (success or failure)
6. Dry run mode works (file unchanged)
7. Permission errors return clear messages
8. All existing tests from Plan 01 still pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-editor-engine/01-02-SUMMARY.md`
</output>
