---
phase: 06-error-response-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/core/errors.ts
  - src/core/reporter.ts
autonomous: true

must_haves:
  truths:
    - "ErrorEnvelope type enforces consistent shape for all error responses"
    - "Error codes classify every failure with retryable indicator"
    - "Context extraction produces 10-15 lines of raw surrounding content"
    - "Per-edit status tracks failed/skipped edits (success edits omitted)"
    - "Recovery hints are arrays of general guidance strings"
  artifacts:
    - path: "src/types/index.ts"
      provides: "ErrorEnvelope, EditStatusEntry, ErrorCode types"
      contains: "ErrorEnvelope"
    - path: "src/core/errors.ts"
      provides: "Error classification, context extraction, envelope creation"
      exports: ["createErrorEnvelope", "classifyError", "extractFileContext", "extractMatchLocations"]
    - path: "src/core/reporter.ts"
      provides: "Updated formatMultiEditResponse using error envelope"
      exports: ["formatMultiEditResponse"]
  key_links:
    - from: "src/core/errors.ts"
      to: "src/types/index.ts"
      via: "imports ErrorEnvelope, EditStatusEntry, ErrorCode"
      pattern: "import.*ErrorEnvelope.*from.*types"
    - from: "src/core/reporter.ts"
      to: "src/core/errors.ts"
      via: "uses createErrorEnvelope for error formatting"
      pattern: "import.*createErrorEnvelope.*from.*errors"
---

<objective>
Define the canonical error types and build the unified error infrastructure (errors.ts) plus refactor reporter.ts to use it.

Purpose: Establish the error envelope shape, error code taxonomy, retryable classification, context extraction (10-15 lines), and per-edit status tracking as foundational building blocks. Then update reporter.ts so formatMultiEditResponse produces the canonical error envelope instead of the current ad-hoc ErrorResponse shape.

Output: Three modified/created files that provide the complete error infrastructure ready for handler consumption.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-error-response-system/06-CONTEXT.md
@.planning/phases/06-error-response-system/06-RESEARCH.md
@src/types/index.ts
@src/core/reporter.ts
@src/core/editor.ts
@src/core/validator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error types and create errors.ts module</name>
  <files>src/types/index.ts, src/core/errors.ts</files>
  <action>
**In `src/types/index.ts`**, add the following types (append after existing types, do NOT modify existing types):

```typescript
/** Error codes for the error taxonomy */
export type ErrorCode =
  // Validation errors (retryable: true)
  | 'VALIDATION_FAILED'
  | 'RELATIVE_PATH'
  | 'PATH_TRAVERSAL'
  | 'EMPTY_EDITS'
  | 'EMPTY_OLD_STRING'
  | 'DUPLICATE_OLD_STRING'
  // Match errors (retryable: true)
  | 'MATCH_NOT_FOUND'
  | 'AMBIGUOUS_MATCH'
  // File system errors (retryable: false)
  | 'FILE_NOT_FOUND'
  | 'PERMISSION_DENIED'
  | 'INVALID_ENCODING'
  | 'DISK_FULL'
  | 'READ_ONLY_FS'
  | 'SYMLINK_LOOP'
  | 'BACKUP_FAILED'
  | 'WRITE_FAILED'
  // Other (retryable: false)
  | 'UNKNOWN_ERROR'
  | 'NOT_IMPLEMENTED'
  | 'UNKNOWN_TOOL';

/** Per-edit status entry (only for failed/skipped edits; success = absence) */
export interface EditStatusEntry {
  edit_index: number;
  status: 'failed' | 'skipped';
  error_code?: ErrorCode;
  message?: string;
  old_string_preview?: string;  // First 40 chars for correlation
}

/** Match location with surrounding context */
export interface MatchLocation {
  line: number;
  snippet: string;
}

/** Context information attached to error responses */
export interface ErrorContext {
  /** Raw surrounding content (10-15 lines, no line numbers) */
  snippet?: string;
  /** All match locations for ambiguous-match errors */
  match_locations?: MatchLocation[];
}

/** Canonical error envelope - all errors produce this shape */
export interface ErrorEnvelope {
  success: false;
  error_code: ErrorCode;
  message: string;
  retryable: boolean;
  file_path?: string;
  edit_index?: number;
  recovery_hints: string[];
  context?: ErrorContext;
  edit_status?: EditStatusEntry[];
  backup_path?: string;
}
```

**Create `src/core/errors.ts`** with these exports:

1. **`RETRYABLE_CODES: Set<ErrorCode>`** - Contains all retryable error codes: `VALIDATION_FAILED`, `RELATIVE_PATH`, `PATH_TRAVERSAL`, `EMPTY_EDITS`, `EMPTY_OLD_STRING`, `DUPLICATE_OLD_STRING`, `MATCH_NOT_FOUND`, `AMBIGUOUS_MATCH`.

2. **`isRetryable(code: ErrorCode): boolean`** - Returns `RETRYABLE_CODES.has(code)`.

3. **`classifyError(error: unknown, filePath?: string): { error_code: ErrorCode; message: string }`** - Classifies a caught error into an error code. Checks `(error as NodeJS.ErrnoException).code` for: ENOENT->FILE_NOT_FOUND, EACCES/EPERM->PERMISSION_DENIED, ENOSPC->DISK_FULL, EROFS->READ_ONLY_FS, ELOOP->SYMLINK_LOOP. Checks message for UTF-8/encoding->INVALID_ENCODING. Falls back to UNKNOWN_ERROR. Message is the original error message if Error instance, otherwise `Unknown error on ${filePath}`.

4. **`getRecoveryHints(errorCode: ErrorCode): string[]`** - Returns an array of recovery hint strings based on error code. Per CONTEXT.md: general guidance, not prescriptive. For MATCH_NOT_FOUND: `["Check for whitespace differences between old_string and file content", "Re-read the file to see its current content before retrying"]`. For AMBIGUOUS_MATCH: `["Use replace_all: true to replace all occurrences", "Make old_string more specific to match only the intended location"]`. For FILE_NOT_FOUND: `["Check that the file path is correct and the file exists"]`. For PERMISSION_DENIED: `["Check file permissions or run with appropriate access"]`. For VALIDATION_FAILED: `["Check input format matches the tool schema"]`. For DUPLICATE_OLD_STRING: `["Each edit must have a unique old_string", "Combine edits or make old_strings more specific"]`. Etc. Return `["Check error details and retry"]` as fallback.

5. **`extractFileContext(fileContent: string, searchString: string): ErrorContext`** - For match-not-found errors. Per CONTEXT.md: 10-15 lines, raw content, no line numbers. Algorithm:
   - Try partial match with progressively shorter prefixes (20 chars, 10, 5)
   - If partial match found: extract 7 lines before and 7 lines after (14 lines)
   - If no partial match: return first 15 lines of file
   - Join lines with \n, no line numbers
   - Return `{ snippet }`.

6. **`extractMatchLocations(fileContent: string, searchString: string, positions: number[]): ErrorContext`** - For ambiguous-match errors. Per CONTEXT.md: show ALL match locations.
   - For each position: find line number, extract 3 lines before and 3 lines after (7 lines per location)
   - Raw content, no line numbers in snippet
   - Cap at 5 locations; include `snippet` noting if more exist (e.g., "5 of 8 matches shown")
   - Return `{ match_locations: [...] }`.

7. **`createErrorEnvelope(opts: { error_code: ErrorCode; message: string; file_path?: string; edit_index?: number; recovery_hints?: string[]; context?: ErrorContext; edit_status?: EditStatusEntry[]; backup_path?: string; }): ErrorEnvelope`** - Factory function. Sets `success: false`, computes `retryable` from `isRetryable(error_code)`, uses `opts.recovery_hints ?? getRecoveryHints(opts.error_code)`. Omits undefined fields from the result (do not include keys with undefined values -- use conditional spread or explicit checks).

8. **`buildEditStatus(edits: Array<{ old_string: string }>, failedIndex: number, failedCode: ErrorCode, failedMessage: string): EditStatusEntry[]`** - Per CONTEXT.md: only list failed/skipped edits, absence means success. For the failed edit: `{ edit_index: failedIndex, status: 'failed', error_code: failedCode, message: failedMessage, old_string_preview: edits[failedIndex].old_string.slice(0, 40) }`. For each subsequent edit (index > failedIndex): `{ edit_index: i, status: 'skipped', old_string_preview: edits[i].old_string.slice(0, 40) }`. Return the array. If failedIndex is the last edit, return just the failed entry (no skipped).

Import types from `../types/index.js`. Do NOT import from reporter.ts (avoid circular dependency).
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Verify `src/core/errors.ts` exists and exports all 8 items. Verify `src/types/index.ts` contains ErrorEnvelope, EditStatusEntry, ErrorCode, MatchLocation, ErrorContext types.
  </verify>
  <done>
ErrorEnvelope type defined. errors.ts module exports createErrorEnvelope, classifyError, extractFileContext, extractMatchLocations, buildEditStatus, getRecoveryHints, isRetryable, RETRYABLE_CODES. All compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor reporter.ts to use error envelope</name>
  <files>src/core/reporter.ts</files>
  <action>
Update `src/core/reporter.ts` to use the new error infrastructure:

1. **Add imports** from `./errors.js`: `createErrorEnvelope`, `extractFileContext`, `extractMatchLocations`, `buildEditStatus`, `getRecoveryHints`. Import `ErrorEnvelope`, `ErrorCode`, `ErrorContext` from `../types/index.js`.

2. **Keep SuccessResponse unchanged** (per discretion: success responses keep current format).

3. **Remove the old ErrorResponse interface.** It is replaced by `ErrorEnvelope` from types.

4. **Update `formatMultiEditResponse` signature** to return `SuccessResponse | ErrorEnvelope` (was `SuccessResponse | ErrorResponse`).

5. **Refactor the error branch of `formatMultiEditResponse`:**
   - Determine `error_code`: Parse from `result.error` string. If includes "not found" -> `MATCH_NOT_FOUND`. If includes "matches at lines" or "occurrences found" -> `AMBIGUOUS_MATCH`. If includes "Permission denied" or "EACCES" -> `PERMISSION_DENIED`. If includes "UTF-8" or "encoding" -> `INVALID_ENCODING`. If includes "Backup failed" -> `BACKUP_FAILED`. Default -> `UNKNOWN_ERROR`.
   - Build `context`: For MATCH_NOT_FOUND, call `extractFileContext(fileContent, failedEdit.old_string)` where `failedEdit = result.results[failedIndex]` (if available). For AMBIGUOUS_MATCH, extract match positions from the error message (parse the line numbers) or re-find them using `findAllMatchPositions` from editor.ts, then call `extractMatchLocations(fileContent, failedEdit.old_string, positions)`.
   - Build `edit_status`: Call `buildEditStatus(editsInfo, failedIndex, error_code, result.error)` where `editsInfo` comes from `result.results` plus remaining edits from the `edits` parameter. To support this, **add an `edits` parameter** to `formatMultiEditResponse`: `edits?: Array<{ old_string: string }>` (the original edits array). When provided, use it for buildEditStatus. When not provided (backward compat), skip edit_status.
   - Call `createErrorEnvelope({ error_code, message: errorMessage, file_path: result.file_path, edit_index: failedIndex, context, edit_status, backup_path: result.backup_path })`.

6. **Remove `getRecoveryHint` function** (replaced by `getRecoveryHints` in errors.ts).

7. **Remove `extractContextSnippet` function** (replaced by `extractFileContext` in errors.ts).

8. **Keep all success-path functions unchanged**: `createSuccessResult`, `createErrorResult`, `createFilesSuccessResult`, `createFilesErrorResult`, `truncateForDisplay`, `generateDiffPreview`. These are still used and their shapes are fine.

9. **Add `import { findAllMatchPositions } from './editor.js'`** for re-finding match positions in ambiguous match errors.

Important: The `formatMultiEditResponse` function signature changes. The new signature:
```typescript
export function formatMultiEditResponse(
  result: MultiEditResult,
  includeContent: boolean,
  totalEdits: number,
  fileContent?: string,
  originalContent?: string,
  edits?: Array<{ old_string: string }>
): SuccessResponse | ErrorEnvelope
```
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Verify reporter.ts no longer exports `getRecoveryHint` or `extractContextSnippet`. Verify `formatMultiEditResponse` returns `ErrorEnvelope` on error paths.
  </verify>
  <done>
reporter.ts error formatting uses ErrorEnvelope via createErrorEnvelope. Old ad-hoc ErrorResponse, getRecoveryHint, and extractContextSnippet removed. Success path unchanged. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. `src/core/errors.ts` exists and exports: createErrorEnvelope, classifyError, extractFileContext, extractMatchLocations, buildEditStatus, getRecoveryHints, isRetryable, RETRYABLE_CODES
3. `src/types/index.ts` contains: ErrorEnvelope, EditStatusEntry, ErrorCode, MatchLocation, ErrorContext
4. `src/core/reporter.ts` uses ErrorEnvelope for error responses, does NOT export getRecoveryHint or extractContextSnippet
5. No circular imports between errors.ts and reporter.ts
</verification>

<success_criteria>
- ErrorEnvelope type is the single canonical error shape
- errors.ts provides all error infrastructure (classification, context extraction, envelope creation)
- reporter.ts formatMultiEditResponse produces ErrorEnvelope on error paths
- All existing success-path behavior unchanged
- Build compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-response-system/06-01-SUMMARY.md`
</output>
