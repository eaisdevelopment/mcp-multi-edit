---
phase: 06-error-response-system
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/tools/multi-edit.ts
  - src/tools/multi-edit-files.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "All 13 error return points produce ErrorEnvelope shape"
    - "Validation errors in multi-edit.ts use createErrorEnvelope with VALIDATION_FAILED"
    - "Validation errors in multi-edit-files.ts use createErrorEnvelope with proper codes"
    - "index.ts catch-all, not-implemented, and unknown-tool errors use createErrorEnvelope"
    - "Stack traces never appear in any error response"
    - "Every error response has isError: true in MCP result"
  artifacts:
    - path: "src/tools/multi-edit.ts"
      provides: "Unified error handling using ErrorEnvelope"
      exports: ["handleMultiEdit"]
    - path: "src/tools/multi-edit-files.ts"
      provides: "Unified error handling using ErrorEnvelope"
      exports: ["handleMultiEditFiles"]
    - path: "src/index.ts"
      provides: "Catch-all error handling using ErrorEnvelope"
  key_links:
    - from: "src/tools/multi-edit.ts"
      to: "src/core/errors.ts"
      via: "imports createErrorEnvelope for validation and catch errors"
      pattern: "import.*createErrorEnvelope.*from.*errors"
    - from: "src/tools/multi-edit-files.ts"
      to: "src/core/errors.ts"
      via: "imports createErrorEnvelope for all error paths"
      pattern: "import.*createErrorEnvelope.*from.*errors"
    - from: "src/index.ts"
      to: "src/core/errors.ts"
      via: "imports createErrorEnvelope and classifyError for catch-all"
      pattern: "import.*createErrorEnvelope.*from.*errors"
---

<objective>
Retrofit all 13 error return points across 3 handler files to use the canonical ErrorEnvelope from errors.ts.

Purpose: Achieve the phase goal of consistent, structured error responses across every failure path. After this plan, every error response in the MCP server follows the same JSON shape with error_code, retryable indicator, recovery_hints array, and contextual information.

Output: Three updated handler files where every error path produces ErrorEnvelope via createErrorEnvelope.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-error-response-system/06-CONTEXT.md
@.planning/phases/06-error-response-system/06-RESEARCH.md
@.planning/phases/06-error-response-system/06-01-SUMMARY.md
@src/types/index.ts
@src/core/errors.ts
@src/core/reporter.ts
@src/tools/multi-edit.ts
@src/tools/multi-edit-files.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Retrofit multi-edit.ts and multi-edit-files.ts handlers</name>
  <files>src/tools/multi-edit.ts, src/tools/multi-edit-files.ts</files>
  <action>
**Update `src/tools/multi-edit.ts`** (3 error paths):

Import `createErrorEnvelope` and `classifyError` from `../core/errors.js`. Import `ErrorEnvelope` from `../types/index.js`.

**Error path 1 (line ~22-34, validation failure):**
Replace the current ad-hoc JSON with:
```typescript
const envelope = createErrorEnvelope({
  error_code: 'VALIDATION_FAILED',
  message: 'Input validation failed',
  recovery_hints: validation.errors.map(e => `${e.code}: ${e.message} (${e.recovery_hint})`),
});
return {
  content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
  isError: true,
};
```

**Error path 2 (line ~52-63, formatMultiEditResponse handles this):**
The `formatMultiEditResponse` now returns `ErrorEnvelope` on failure. Update the call to pass the `edits` array for per-edit status:
```typescript
const response = formatMultiEditResponse(
  result,
  input.include_content ?? false,
  input.edits.length,
  fileContent,
  fileContent,
  input.edits  // NEW: pass edits for per-edit status in ErrorEnvelope
);
```
This path is already correct because `formatMultiEditResponse` was updated in 06-01.

**Error path 3 (line ~64-77, catch block):**
Replace with:
```typescript
} catch (error) {
  const classified = classifyError(error, input.file_path);
  const envelope = createErrorEnvelope({
    error_code: classified.error_code,
    message: classified.message,
    file_path: input.file_path,
  });
  return {
    content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
    isError: true,
  };
}
```
Remove import of `createErrorResult` from reporter.ts (no longer needed in this file).

---

**Update `src/tools/multi-edit-files.ts`** (5 error paths):

Import `createErrorEnvelope` and `classifyError` from `../core/errors.js`. Import `ErrorEnvelope` from `../types/index.js`.

**Error path 4 (line ~25-33, Zod validation failure):**
Replace bare `{ error: "Validation failed: ..." }` with:
```typescript
const errorMessages = validation.error.issues
  .map(i => `${i.path.join('.')}: ${i.message}`)
  .join('; ');
const envelope = createErrorEnvelope({
  error_code: 'VALIDATION_FAILED',
  message: `Validation failed: ${errorMessages}`,
});
return {
  content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
  isError: true,
};
```

**Error path 5 (line ~38-49, relative path check):**
Replace bare `{ error: "files[i].file_path must be absolute" }` with:
```typescript
const envelope = createErrorEnvelope({
  error_code: 'RELATIVE_PATH',
  message: `files[${i}].file_path must be an absolute path`,
  file_path: input.files[i].file_path,
});
return {
  content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
  isError: true,
};
```

**Error paths 6-7 (line ~77-99, per-file failure):**
When a file edit fails (result.success === false), or when an exception occurs per-file:
```typescript
// For result.success === false:
const envelope = createErrorEnvelope({
  error_code: 'WRITE_FAILED',  // Or parse from result.error
  message: `Failed to edit file ${fileEdit.file_path}: ${result.error}`,
  file_path: fileEdit.file_path,
  edit_index: i,  // file index, not edit index
});
return {
  content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
  isError: true,
};
```
For the exception catch within the per-file loop:
```typescript
const classified = classifyError(error, fileEdit.file_path);
const envelope = createErrorEnvelope({
  error_code: classified.error_code,
  message: `Error editing file ${fileEdit.file_path}: ${classified.message}`,
  file_path: fileEdit.file_path,
  edit_index: i,
});
```

**Error path 8 (line ~108-114, outer catch):**
```typescript
} catch (error) {
  const classified = classifyError(error);
  const envelope = createErrorEnvelope({
    error_code: classified.error_code,
    message: classified.message,
  });
  return {
    content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
    isError: true,
  };
}
```

Remove imports of `formatMultiEditFilesResult` and `createFilesErrorResult` from reporter.ts if they are no longer used in this file. Keep `createFilesSuccessResult` and `formatMultiEditFilesResult` for the success path.

For the per-file failure (error path 6), improve the error_code detection: if `result.error` includes "not found" -> MATCH_NOT_FOUND, "matches at lines" -> AMBIGUOUS_MATCH, "Permission denied" -> PERMISSION_DENIED, "Backup failed" -> BACKUP_FAILED, "UTF-8" -> INVALID_ENCODING. Otherwise UNKNOWN_ERROR.
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Check that multi-edit.ts has no bare `{ error: "..." }` objects in error returns. Check that multi-edit-files.ts has no bare `{ error: "..." }` objects in error returns. All error returns use `createErrorEnvelope`.
  </verify>
  <done>
All 8 error paths in multi-edit.ts (3) and multi-edit-files.ts (5) produce ErrorEnvelope via createErrorEnvelope. No bare error objects remain. isError: true on all error returns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Retrofit index.ts catch-all error handlers</name>
  <files>src/index.ts</files>
  <action>
Import `createErrorEnvelope` and `classifyError` from `./core/errors.js`.

**Error path 9 (line ~146-154, not implemented):**
Replace `{ error: 'Not implemented yet' }` with:
```typescript
const envelope = createErrorEnvelope({
  error_code: 'NOT_IMPLEMENTED',
  message: 'multi_edit_files is not implemented yet',
});
return {
  content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
  isError: true,
};
```

**Error path 10 (line ~157-165, unknown tool):**
Replace `{ error: \`Unknown tool: ${name}\` }` with:
```typescript
const envelope = createErrorEnvelope({
  error_code: 'UNKNOWN_TOOL',
  message: `Unknown tool: ${name}`,
});
return {
  content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
  isError: true,
};
```

**Error path 11 (line ~166-177, outer catch):**
Replace bare `{ error: message }` with:
```typescript
} catch (error) {
  const classified = classifyError(error);
  const envelope = createErrorEnvelope({
    error_code: classified.error_code,
    message: classified.message,
  });
  return {
    content: [{ type: 'text', text: JSON.stringify(envelope, null, 2) }],
    isError: true,
  };
}
```

This ensures stack traces from caught errors are never exposed -- classifyError extracts only the message string, never the stack.
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Verify index.ts has no bare `{ error: "..." }` objects. All 3 error paths use createErrorEnvelope. Grep for `stack` in error responses to confirm no stack trace exposure.
  </verify>
  <done>
All 3 error paths in index.ts produce ErrorEnvelope. No bare error objects. No stack traces exposed. Build passes clean.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. `grep -rn '{ error:' src/` returns zero matches in error return paths (only in type definitions if any)
3. All error responses in handler files use `createErrorEnvelope`
4. Every error return has `isError: true`
5. `grep -rn 'stack' src/tools/ src/index.ts` shows no stack trace exposure
6. Test with a quick manual check: build succeeds and server starts without error
</verification>

<success_criteria>
- All 13 error return points (3 in multi-edit.ts, 5 in multi-edit-files.ts, 3 in index.ts, 2 in reporter.ts via formatMultiEditResponse) produce canonical ErrorEnvelope
- No bare `{ error: "..." }` objects remain in any handler
- Every error response has isError: true in MCP result
- Stack traces never exposed
- Build compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-response-system/06-02-SUMMARY.md`
</output>
