---
phase: 03-validation-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/validator.ts
  - src/types/index.ts
  - src/tools/multi-edit.ts
autonomous: true

must_haves:
  truths:
    - "Relative paths are rejected with error message including recovery hint"
    - "Paths containing '..' segments are rejected as directory traversal"
    - "Non-existent files are rejected with FILE_NOT_FOUND error"
    - "Duplicate old_strings in edits array are rejected with edit indices"
    - "All validation errors occur before any file read/write operations"
  artifacts:
    - path: "src/types/index.ts"
      provides: "ValidationError and ValidationResult types"
      contains: "interface ValidationError"
    - path: "src/core/validator.ts"
      provides: "Path validation, duplicate detection, full validation"
      exports: ["validatePath", "detectDuplicateOldStrings", "validateMultiEditInputFull"]
    - path: "src/tools/multi-edit.ts"
      provides: "Handler using full validation"
      contains: "validateMultiEditInputFull"
  key_links:
    - from: "src/tools/multi-edit.ts"
      to: "src/core/validator.ts"
      via: "validateMultiEditInputFull call"
      pattern: "validateMultiEditInputFull\\(args\\)"
    - from: "src/core/validator.ts"
      to: "node:path"
      via: "path.isAbsolute import"
      pattern: "import.*from 'node:path'"
    - from: "src/core/validator.ts"
      to: "node:fs/promises"
      via: "fs.realpath for existence check"
      pattern: "realpath"
---

<objective>
Implement validation layer that rejects invalid inputs before any file operations occur.

Purpose: Ensure bad inputs fail fast with actionable error messages, preventing wasted file I/O and protecting against path security issues.
Output: Enhanced validator.ts with path validation, duplicate detection, and file existence checking; handler wired to use full validation.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-validation-layer/03-CONTEXT.md
@.planning/phases/03-validation-layer/03-RESEARCH.md
@src/core/validator.ts
@src/tools/multi-edit.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ValidationError types and path validation</name>
  <files>src/types/index.ts, src/core/validator.ts</files>
  <action>
Add ValidationError and ValidationResult types to src/types/index.ts:

```typescript
export interface ValidationError {
  code: string;           // Machine-readable: 'RELATIVE_PATH', 'PATH_TRAVERSAL', etc.
  message: string;        // Human-readable with received value
  path?: string[];        // JSON path: ['file_path'] or ['edits', '2', 'old_string']
  recovery_hint: string;  // Actionable guidance
}

export type ValidationResult<T> =
  | { success: true; data: T }
  | { success: false; errors: ValidationError[] };
```

In src/core/validator.ts, add path validation:

1. Import `path` from 'node:path' and `fs` from 'node:fs/promises'
2. Replace the simple `isAbsolutePath` with proper `validatePath`:
   - Use `path.isAbsolute()` (handles cross-platform correctly)
   - Check for '..' segments in the path
   - Return null for valid, ValidationError for invalid
3. Add `validateFileExists` async function:
   - Use `fs.realpath()` which resolves symlinks AND checks existence
   - Handle ENOENT, EACCES, EPERM, ELOOP error codes
   - Return `{ resolvedPath: string }` on success, ValidationError on failure

Keep existing `isAbsolutePath` function for backward compatibility but mark as deprecated.
  </action>
  <verify>npm run build passes. Types exported correctly.</verify>
  <done>ValidationError/ValidationResult types exist. validatePath rejects relative paths and '..' paths. validateFileExists resolves symlinks and rejects missing files.</done>
</task>

<task type="auto">
  <name>Task 2: Add duplicate edit detection with Zod superRefine</name>
  <files>src/core/validator.ts</files>
  <action>
Enhance duplicate detection in src/core/validator.ts:

1. Add `detectDuplicateOldStrings` function:
   - Takes edits array, returns ValidationError[]
   - Uses Map to track first occurrence index of each old_string
   - For duplicates, include edit index ("Edit 2 of 5") and truncated snippet
   - Use existing `truncateForDisplay` from reporter.ts (import it)

2. Update EditsArraySchema or create enhanced version with superRefine:
   - After basic array validation, use `.superRefine()` to check duplicates
   - Add custom issue with code 'DUPLICATE_OLD_STRING'

3. Create `validateMultiEditInputFull` async function that implements layered validation:
   - Layer 1: Schema validation with Zod safeParse (synchronous)
   - Layer 2: Path validation with validatePath (synchronous)
   - Layer 3: Duplicate detection with detectDuplicateOldStrings (synchronous)
   - Layer 4: File existence with validateFileExists (async)
   - Return ValidationResult<MultiEditInput>

4. Add helper `formatZodErrors` to convert ZodError to ValidationError[]:
   - Map each issue to ValidationError with code, message, path, recovery_hint
   - Use issue.code to determine appropriate recovery_hint
  </action>
  <verify>npm run build passes. Create a test file with duplicate edits and verify detection works.</verify>
  <done>detectDuplicateOldStrings finds exact duplicate old_strings. validateMultiEditInputFull implements full layered validation.</done>
</task>

<task type="auto">
  <name>Task 3: Wire full validation into multi-edit handler</name>
  <files>src/tools/multi-edit.ts</files>
  <action>
Update src/tools/multi-edit.ts to use new validation:

1. Import validateMultiEditInputFull instead of validateMultiEditInput
2. Remove the separate isAbsolutePath check (now handled by validateMultiEditInputFull)
3. Replace the validation block:

Before:
```typescript
const validation = validateMultiEditInput(args);
if (!validation.success) { ... }
const input = validation.data as MultiEditInput;
if (!isAbsolutePath(input.file_path)) { ... }
```

After:
```typescript
const validation = await validateMultiEditInputFull(args);
if (!validation.success) {
  const errorMessages = validation.errors.map(e =>
    `${e.code}: ${e.message} (Hint: ${e.recovery_hint})`
  ).join('\n');
  return {
    content: [{ type: 'text', text: JSON.stringify({
      success: false,
      error: 'Validation failed',
      errors: validation.errors,
      message: errorMessages
    }, null, 2) }],
    isError: true,
  };
}
const input = validation.data;
// Note: file_path may now be resolved (symlinks followed)
```

4. Remove the try/catch block around readFile for context snippets - the file is now guaranteed to exist after validation passes.

5. Update the function signature if needed to be async (already is).
  </action>
  <verify>npm run build passes. Test with relative path - should get structured error. Test with absolute path to missing file - should get FILE_NOT_FOUND.</verify>
  <done>Handler uses validateMultiEditInputFull. Validation errors return structured ValidationError array. No file operations before validation passes.</done>
</task>

</tasks>

<verification>
1. Build: `npm run build` completes without errors
2. Relative path test: Call multi_edit with `file_path: "./test.ts"` - should return RELATIVE_PATH error with recovery hint
3. Traversal test: Call multi_edit with `file_path: "/home/../etc/passwd"` - should return PATH_TRAVERSAL error
4. Missing file test: Call multi_edit with `file_path: "/nonexistent/file.ts"` - should return FILE_NOT_FOUND error
5. Duplicate test: Call multi_edit with two edits having same old_string - should return DUPLICATE_OLD_STRING error
</verification>

<success_criteria>
- All validation errors include: code, message, path, recovery_hint
- Relative paths rejected before any file I/O
- Directory traversal (..) paths rejected before any file I/O
- Missing files rejected after path validation, before any edit operations
- Duplicate old_strings rejected with edit indices in message
- Valid inputs with existing absolute paths proceed to editor
</success_criteria>

<output>
After completion, create `.planning/phases/03-validation-layer/03-01-SUMMARY.md`
</output>
