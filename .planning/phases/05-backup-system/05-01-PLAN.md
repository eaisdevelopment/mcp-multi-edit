---
phase: 05-backup-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/core/validator.ts
  - src/core/editor.ts
  - src/core/reporter.ts
  - src/tools/multi-edit.ts
  - src/tools/multi-edit-files.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "A .bak file with original content exists after a successful edit (backup defaults ON)"
    - "Backup file has same permissions as the original file"
    - "backup_path is returned in success responses when backup was created"
    - "backup_path is returned in error responses when backup succeeded but edit failed"
    - "Backup failure aborts the entire edit operation with specific error message"
    - "Dry-run with backup=true creates the .bak file and returns backup_path"
    - "backup: false skips backup creation entirely"
  artifacts:
    - path: "src/core/editor.ts"
      provides: "createBackup function, formatBackupError function, restructured applyEdits with backup-before-edits flow"
      contains: "createBackup"
    - path: "src/core/reporter.ts"
      provides: "ErrorResponse with backup_path field"
      contains: "backup_path"
    - path: "src/types/index.ts"
      provides: "backup field on MultiEditInput and MultiEditFilesInput"
      contains: "backup?"
    - path: "src/core/validator.ts"
      provides: "backup Zod field with default true"
      contains: "backup:"
    - path: "src/index.ts"
      provides: "Tool schema with backup property defaulting to true"
      contains: "backup"
  key_links:
    - from: "src/core/editor.ts:applyEdits"
      to: "src/core/editor.ts:createBackup"
      via: "Called before applyEditsToContent and before dry-run return"
      pattern: "createBackup\\(filePath, content\\)"
    - from: "src/core/editor.ts:applyEdits"
      to: "result.backup_path"
      via: "Attached to result on both success and failure paths"
      pattern: "backup_path"
    - from: "src/tools/multi-edit.ts"
      to: "applyEdits"
      via: "Passes input.backup (renamed from input.create_backup)"
      pattern: "input\\.backup"
    - from: "src/core/reporter.ts:ErrorResponse"
      to: "backup_path"
      via: "Optional field on error response type"
      pattern: "backup_path\\?"
---

<objective>
Implement the backup system: create .bak files preserving original content before edits are applied.

Purpose: Safety net allowing manual restoration if edits produce undesired results. Backup defaults ON (opt-out with `backup: false`). Backup failure aborts the operation -- no edit without backup.

Output: Fully wired backup system across all 7 source files, with parameter renamed from `create_backup` to `backup`, default changed from `false` to `true`, and `applyEdits` restructured to backup BEFORE edits/dry-run.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-backup-system/05-CONTEXT.md
@.planning/phases/05-backup-system/05-RESEARCH.md
@src/types/index.ts
@src/core/editor.ts
@src/core/reporter.ts
@src/core/validator.ts
@src/tools/multi-edit.ts
@src/tools/multi-edit-files.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename create_backup to backup and change default to true</name>
  <files>
    src/types/index.ts
    src/core/validator.ts
    src/tools/multi-edit.ts
    src/tools/multi-edit-files.ts
    src/index.ts
  </files>
  <action>
    Rename the `create_backup` parameter to `backup` across all surface-level files and change the default from `false` to `true`. Per user decision: "Backup on by default, opt-out with `backup: false` parameter."

    **src/types/index.ts:**
    - On MultiEditInput (line 51): rename `create_backup?: boolean` to `backup?: boolean`, update comment to "Create backup before editing (default: true)"
    - On MultiEditFilesInput (line 68): rename `create_backup?: boolean` to `backup?: boolean`, update comment to "Create backup files before editing (default: true)"

    **src/core/validator.ts:**
    - MultiEditInputSchema (line 27): rename `create_backup` to `backup`, change `.default(false)` to `.default(true)`
    - MultiEditFilesInputSchema (line 42): rename `create_backup` to `backup`, change `.default(false)` to `.default(true)`

    **src/tools/multi-edit.ts:**
    - Line 49: change `input.create_backup` to `input.backup`

    **src/tools/multi-edit-files.ts:**
    - Line 73: change `input.create_backup` to `input.backup`

    **src/index.ts:**
    - multi_edit tool schema (line 70-73): rename `create_backup` property to `backup`, update description to "Create .bak backup file before editing (default: true)"
    - multi_edit_files tool schema (line 120-123): rename `create_backup` property to `backup`, update description to "Create .bak backup files before editing (default: true)"
  </action>
  <verify>
    Run `npm run build` to confirm TypeScript compiles with no errors after the rename.
    Grep for `create_backup` in src/ -- should return zero matches.
    Grep for `backup` in src/core/validator.ts -- should show `.default(true)`.
  </verify>
  <done>
    All references to `create_backup` are renamed to `backup`. Default is `true` in both Zod schemas and tool schema descriptions. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement backup-before-edits in editor.ts and add backup_path to ErrorResponse</name>
  <files>
    src/core/editor.ts
    src/core/reporter.ts
  </files>
  <action>
    Restructure `applyEdits()` in editor.ts to create backup BEFORE applying edits, add permission preservation, add backup-specific error formatting, and ensure backup_path flows through both success and error paths. Also update ErrorResponse in reporter.ts to include backup_path.

    **src/core/reporter.ts:**
    - Add `backup_path?: string;` to the ErrorResponse interface (after `context_snippet`)
    - In `formatMultiEditResponse`, in the error branch (around line 252-273): after constructing the error response object, add: if `result.backup_path` exists, set `response.backup_path = result.backup_path`

    **src/core/editor.ts:**

    1. Add a new exported function `createBackup`:
    ```typescript
    export async function createBackup(
      filePath: string,
      content: string
    ): Promise<string> {
      const backupPath = `${filePath}.bak`;
      const stats = await fs.stat(filePath);
      await fs.writeFile(backupPath, content, 'utf8');
      await fs.chmod(backupPath, stats.mode & 0o7777);
      return backupPath;
    }
    ```
    This uses `fs.writeFile` (content already in memory, avoids re-read). Uses `stats.mode & 0o7777` for clean permission masking. If `fs.stat` fails, the error propagates (per research: treat stat failure as backup failure since user locked "Preserve original file permissions").

    2. Add a new exported function `formatBackupError`:
    ```typescript
    export function formatBackupError(error: unknown, backupPath: string): string {
      if (error instanceof Error) {
        const nodeError = error as NodeJS.ErrnoException;
        if (nodeError.code === 'EACCES' || nodeError.code === 'EPERM') {
          return `Backup failed: Permission denied on ${backupPath}`;
        }
        if (nodeError.code === 'ENOSPC') {
          return `Backup failed: No space left on device for ${backupPath}`;
        }
        if (nodeError.code === 'EROFS') {
          return `Backup failed: Read-only file system for ${backupPath}`;
        }
        return `Backup failed: ${error.message} on ${backupPath}`;
      }
      return `Backup failed: Unknown error on ${backupPath}`;
    }
    ```

    3. Restructure `applyEdits()` signature and body:
    - Rename parameter `createBackup` to `backup`, change default from `false` to `true`
    - Update JSDoc accordingly

    New flow for applyEdits (replaces the existing body after the file read):
    ```
    // 1. Read file (existing - unchanged)
    // 2. Create backup BEFORE any edits (if requested)
    let backupPath: string | undefined;
    if (backup) {
      try {
        backupPath = await createBackup(filePath, content);
      } catch (error) {
        return {
          success: false,
          file_path: filePath,
          edits_applied: 0,
          results: [],
          error: formatBackupError(error, `${filePath}.bak`),
          dry_run: dryRun,
        };
      }
    }

    // 3. Apply edits in memory
    const result = applyEditsToContent(filePath, content, edits, dryRun);

    // 4. Attach backup_path to result (success OR failure)
    if (backupPath) {
      result.backup_path = backupPath;
    }

    // 5. If edits failed or dry run, return (backup already created, path attached)
    if (!result.success || dryRun) {
      return result;
    }

    // 6. Write result atomically (existing - unchanged)
    // 7. Return result (existing - unchanged)
    ```

    Key changes from current code:
    - Backup moves from step 4 (after edits) to step 2 (before edits)
    - Backup now happens BEFORE the dry-run early return (user locked: "Dry-run mode DOES create backup")
    - backup_path attaches to result on ALL paths (success, edit failure, dry-run)
    - Backup failure returns immediately with backup-specific error message (user locked: "Error message includes specific reason")
    - Permission preservation added (user locked: "Preserve original file permissions")
    - When backup succeeds but edit fails, backup_path is in the result (user locked: "Include backup_path in error response when backup succeeded but edit failed")
  </action>
  <verify>
    Run `npm run build` to confirm TypeScript compiles cleanly.
    Run `npm test` -- existing tests should still pass (backup defaults to true now, but existing tests that don't assert on .bak files should still work; if any tests break due to .bak file creation, they may need temp directory cleanup -- fix as needed).
  </verify>
  <done>
    - `createBackup` function exists and preserves permissions
    - `formatBackupError` function exists with specific error messages for EACCES/EPERM/ENOSPC/EROFS
    - `applyEdits` creates backup BEFORE edits, BEFORE dry-run return
    - `backup_path` flows through success, error, and dry-run result paths
    - ErrorResponse type includes optional `backup_path`
    - Error response formatter includes `backup_path` when present on result
    - All existing tests pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npm run build` succeeds with zero errors
2. `npm test` passes (all existing tests)
3. No references to `create_backup` remain in src/ directory
4. `backup` parameter defaults to `true` in Zod schemas
5. `createBackup` function exists in editor.ts
6. `formatBackupError` function exists in editor.ts
7. `ErrorResponse` type includes `backup_path` in reporter.ts
8. In `applyEdits`, backup creation occurs BEFORE `applyEditsToContent` call
9. In `applyEdits`, backup creation occurs BEFORE the `if (!result.success || dryRun)` return
</verification>

<success_criteria>
- .bak file is created with original content before any edits apply (backup before edits, not after)
- Backup preserves original file permissions using fs.stat + fs.chmod
- backup_path appears in success response, error response (edit failure), and dry-run response
- Backup failure aborts operation with specific error message (e.g., "Backup failed: Permission denied on /path/file.bak")
- Default behavior (no backup param) creates backup
- backup: false skips backup entirely
- Dry-run with backup creates the .bak file
- All existing tests pass, TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/05-backup-system/05-01-SUMMARY.md`
</output>
