---
phase: 04-dry-run-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/reporter.ts
  - src/tools/multi-edit.ts
autonomous: true

must_haves:
  truths:
    - "User sees 'DRY RUN' label in response when dry_run=true"
    - "User sees line-by-line diff preview showing what would change"
    - "File content is unchanged after dry_run=true operation"
    - "Dry-run returns same success/failure status as real run would"
  artifacts:
    - path: "src/core/reporter.ts"
      provides: "Enhanced dry-run response formatting with diff preview"
      exports: ["formatMultiEditResponse", "generateDiffPreview"]
    - path: "src/tools/multi-edit.ts"
      provides: "Handler passes original content to reporter for diff"
      contains: "generateDiffPreview"
  key_links:
    - from: "src/tools/multi-edit.ts"
      to: "src/core/reporter.ts"
      via: "generateDiffPreview call for dry-run"
      pattern: "generateDiffPreview\\("
    - from: "src/core/reporter.ts"
      to: "formatMultiEditResponse"
      via: "diff_preview field in SuccessResponse"
      pattern: "diff_preview"
---

<objective>
Enhance dry-run mode to provide clear visual feedback and diff previews.

Purpose: When users set dry_run=true, they should get clear indication that no changes were made plus a diff showing what WOULD change. This enables confident verification before committing to edits.
Output: Enhanced reporter with diff preview integration, handler wiring for dry-run context.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/core/reporter.ts
@src/core/editor.ts
@src/tools/multi-edit.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance reporter for dry-run responses with diff preview</name>
  <files>src/core/reporter.ts</files>
  <action>
Update src/core/reporter.ts to enhance dry-run responses:

1. Update SuccessResponse interface to include optional dry-run fields:
```typescript
export interface SuccessResponse {
  success: true;
  file_path: string;
  edits_applied: number;
  dry_run: boolean;
  message?: string;           // Add for dry-run messaging
  diff_preview?: string;      // Add for line-by-line diff
  edits: Array<{
    old_string: string;
    matched: boolean;
    occurrences_replaced: number;
  }>;
  backup_path?: string;
  final_content?: string;
}
```

2. Update `formatMultiEditResponse` signature to accept optional `originalContent` parameter:
```typescript
export function formatMultiEditResponse(
  result: MultiEditResult,
  includeContent: boolean,
  totalEdits: number,
  fileContent?: string,
  originalContent?: string  // Add this parameter
): SuccessResponse | ErrorResponse
```

3. In the success branch of `formatMultiEditResponse`, when `result.dry_run === true`:
   - Add `message: 'DRY RUN - No changes made to file'`
   - If `originalContent` and `result.final_content` are both available, call the existing `generateDiffPreview()` function and include the result in `diff_preview` field

4. Enhance the existing `generateDiffPreview` function (lines 263-293) to handle edge cases:
   - If original === new, return "No changes" instead of just the header lines
   - Add line numbers to the diff output for easier reference (e.g., "L15: - old line" / "L15: + new line")
  </action>
  <verify>npm run build passes. Manually inspect that SuccessResponse type now has message and diff_preview fields.</verify>
  <done>SuccessResponse has message and diff_preview fields. formatMultiEditResponse generates diff preview for dry-run operations. generateDiffPreview includes line numbers and handles no-change case.</done>
</task>

<task type="auto">
  <name>Task 2: Wire handler to pass original content for dry-run diff</name>
  <files>src/tools/multi-edit.ts</files>
  <action>
Update src/tools/multi-edit.ts to provide original content for diff generation:

IMPORTANT: The wiring is safe because:
- `fileContent` is read on line 41 BEFORE `applyEdits` is called
- When `dry_run=true`, `applyEdits` does NOT write to the file (it computes changes but skips the write)
- Therefore, `fileContent` always represents the original file state when passed to the reporter
- The `diff_preview` is ONLY generated when `dry_run=true` in the reporter, so for non-dry-run cases the original content parameter is ignored

Update the `formatMultiEditResponse` call (currently lines 52-57) to pass original content as the 5th parameter:
```typescript
const response = formatMultiEditResponse(
  result,
  input.include_content ?? false,
  input.edits.length,
  fileContent,
  fileContent  // Pass as originalContent - safe because file not modified when dry_run=true
);
```
  </action>
  <verify>npm run build passes. Test dry_run=true and verify response includes message and diff_preview fields.</verify>
  <done>Handler passes original content to reporter. Dry-run responses include 'DRY RUN' message and diff preview showing line numbers.</done>
</task>

<task type="auto">
  <name>Task 3: Verify dry-run file safety and error parity</name>
  <files>None (verification only)</files>
  <action>
Create verification tests to confirm:
A) File unchanged after dry-run
B) Dry-run returns same error format as real run for validation failures

**Part A: File safety verification**

1. Create a test file:
```bash
echo "line one\nline two\nline three" > /tmp/dry-run-test.txt
cat /tmp/dry-run-test.txt
```

2. Note the exact content and timestamp:
```bash
md5 /tmp/dry-run-test.txt
stat -f "%m" /tmp/dry-run-test.txt
```

3. Start the MCP server and send a dry-run request (or use npx tsx to run a quick test script):
```bash
# Create test script
cat > /tmp/test-dry-run.ts << 'EOF'
import { handleMultiEdit } from './src/tools/multi-edit.js';

async function test() {
  const result = await handleMultiEdit({
    file_path: '/tmp/dry-run-test.txt',
    edits: [
      { old_string: 'line two', new_string: 'LINE TWO MODIFIED' }
    ],
    dry_run: true
  });
  console.log(result.content[0].text);
}
test();
EOF
```

4. Run the test:
```bash
cd /path/to/project
npx tsx /tmp/test-dry-run.ts
```

5. Verify file unchanged:
```bash
cat /tmp/dry-run-test.txt
md5 /tmp/dry-run-test.txt  # Should match step 2
stat -f "%m" /tmp/dry-run-test.txt  # Timestamp should match step 2
```

6. Verify response contains:
   - `"dry_run": true`
   - `"message": "DRY RUN - No changes made to file"`
   - `"diff_preview"` showing the change that would have been made with line numbers

**Part B: Error parity verification**

Test that validation errors return the SAME error format regardless of dry_run value:

7. Test "old_string not found" error - dry_run=true vs dry_run=false:
```bash
cat > /tmp/test-error-parity.ts << 'EOF'
import { handleMultiEdit } from './src/tools/multi-edit.js';

async function testErrorParity() {
  console.log('=== Testing error parity: old_string not found ===\n');

  // Test with dry_run=true
  const dryResult = await handleMultiEdit({
    file_path: '/tmp/dry-run-test.txt',
    edits: [{ old_string: 'NONEXISTENT STRING', new_string: 'replacement' }],
    dry_run: true
  });

  // Test with dry_run=false
  const realResult = await handleMultiEdit({
    file_path: '/tmp/dry-run-test.txt',
    edits: [{ old_string: 'NONEXISTENT STRING', new_string: 'replacement' }],
    dry_run: false
  });

  const dryParsed = JSON.parse(dryResult.content[0].text);
  const realParsed = JSON.parse(realResult.content[0].text);

  console.log('dry_run=true response:');
  console.log(JSON.stringify(dryParsed, null, 2));
  console.log('\ndry_run=false response:');
  console.log(JSON.stringify(realParsed, null, 2));

  // Verify same error structure
  console.log('\n=== Parity Check ===');
  console.log('Both success=false:', dryParsed.success === false && realParsed.success === false);
  console.log('Both have error field:', 'error' in dryParsed && 'error' in realParsed);
  console.log('Both have recovery_hint:', 'recovery_hint' in dryParsed && 'recovery_hint' in realParsed);
  console.log('Both isError=true:', dryResult.isError === true && realResult.isError === true);
}
testErrorParity();
EOF
npx tsx /tmp/test-error-parity.ts
```

8. Test "multiple matches" error - dry_run=true vs dry_run=false:
```bash
# First create file with duplicate content
echo "foo bar\nfoo baz\nfoo qux" > /tmp/multi-match-test.txt

cat > /tmp/test-multi-match-parity.ts << 'EOF'
import { handleMultiEdit } from './src/tools/multi-edit.js';

async function testMultiMatchParity() {
  console.log('=== Testing error parity: multiple matches ===\n');

  // Test with dry_run=true (no replace_all, should error on multiple matches)
  const dryResult = await handleMultiEdit({
    file_path: '/tmp/multi-match-test.txt',
    edits: [{ old_string: 'foo', new_string: 'FOO' }],
    dry_run: true
  });

  // Test with dry_run=false
  const realResult = await handleMultiEdit({
    file_path: '/tmp/multi-match-test.txt',
    edits: [{ old_string: 'foo', new_string: 'FOO' }],
    dry_run: false
  });

  const dryParsed = JSON.parse(dryResult.content[0].text);
  const realParsed = JSON.parse(realResult.content[0].text);

  console.log('dry_run=true response:');
  console.log(JSON.stringify(dryParsed, null, 2));
  console.log('\ndry_run=false response:');
  console.log(JSON.stringify(realParsed, null, 2));

  // Verify same error structure
  console.log('\n=== Parity Check ===');
  console.log('Both success=false:', dryParsed.success === false && realParsed.success === false);
  console.log('Both have error field:', 'error' in dryParsed && 'error' in realParsed);
  console.log('Both isError=true:', dryResult.isError === true && realResult.isError === true);
}
testMultiMatchParity();
EOF
npx tsx /tmp/test-multi-match-parity.ts
```
  </action>
  <verify>
Part A: File content, MD5, and timestamp unchanged after dry-run. Response shows dry-run message and diff preview.
Part B: Both "not found" and "multiple matches" errors return same format (success=false, error field, recovery_hint) for dry_run=true and dry_run=false.
  </verify>
  <done>
Manual verification confirms:
1. Dry-run does not modify files (MD5/timestamp match)
2. Response includes clear dry-run indicator and diff preview with line numbers
3. Validation errors (not found, multiple matches) return identical error format regardless of dry_run value
  </done>
</task>

</tasks>

<verification>
1. Build: `npm run build` completes without errors
2. Dry-run response test: Call multi_edit with dry_run=true on existing file
   - Response includes `"message": "DRY RUN - No changes made to file"`
   - Response includes `"diff_preview"` with line-by-line diff format and line numbers
   - Response has `"dry_run": true`
3. File safety test: After dry_run=true call, verify file content unchanged (MD5 + timestamp match)
4. Error parity tests:
   - old_string not found: dry_run=true and dry_run=false return same error structure
   - multiple matches (no replace_all): dry_run=true and dry_run=false return same error structure
   - Both have: success=false, error field, recovery_hint, isError=true
</verification>

<success_criteria>
- Dry-run responses clearly labeled with "DRY RUN" message
- Diff preview shows what changes would be applied with line numbers
- File content verified unchanged after dry-run operation
- Same success/failure behavior whether dry_run=true or false (error parity confirmed)
- Build passes, no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-dry-run-mode/04-01-SUMMARY.md`
</output>
