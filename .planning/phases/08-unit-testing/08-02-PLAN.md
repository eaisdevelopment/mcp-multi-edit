---
phase: 08-unit-testing
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - package.json
  - tests/unit/editor-io.test.ts
  - tests/unit/validator-async.test.ts
autonomous: true

must_haves:
  truths:
    - "memfs is installed as dev dependency and usable in tests"
    - "Editor IO functions (readFileValidated, atomicWrite, createBackup) are tested with in-memory filesystem"
    - "Validator async functions (validateFileExists, detectDuplicateFilePaths, validateMultiEditInputFull, validateMultiEditFilesInputFull) are tested with in-memory filesystem"
    - "All memfs-based tests pass via npm test without touching real filesystem"
  artifacts:
    - path: "tests/unit/editor-io.test.ts"
      provides: "Filesystem-mocked unit tests for editor.ts IO functions"
      min_lines: 80
    - path: "tests/unit/validator-async.test.ts"
      provides: "Filesystem-mocked unit tests for validator.ts async functions"
      min_lines: 100
  key_links:
    - from: "tests/unit/editor-io.test.ts"
      to: "src/core/editor.ts"
      via: "dynamic import after vi.mock"
      pattern: "vi\\.mock.*fs"
    - from: "tests/unit/validator-async.test.ts"
      to: "src/core/validator.ts"
      via: "dynamic import after vi.mock"
      pattern: "vi\\.mock.*fs"
---

<objective>
Install memfs and write filesystem-mocked unit tests for all IO-dependent functions in editor.ts and validator.ts.

Purpose: Close the remaining coverage gaps that require filesystem interaction -- readFileValidated (partial coverage), atomicWrite (partial), createBackup (0% covered), validateFileExists (0% covered), detectDuplicateFilePaths (0% covered), validateMultiEditInputFull (0% covered), validateMultiEditFilesInputFull (0% covered). Using memfs makes tests fast, deterministic, and CI-safe.

Output: memfs dev dependency installed, two new test files with comprehensive IO-mocked test coverage.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-unit-testing/08-RESEARCH.md
@.planning/phases/08-unit-testing/08-01-SUMMARY.md
@src/core/editor.ts
@src/core/validator.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install memfs and create editor IO tests</name>
  <files>package.json, tests/unit/editor-io.test.ts</files>
  <action>
**Step 1: Install memfs**
```bash
npm install --save-dev memfs
```

**Step 2: Create tests/unit/editor-io.test.ts**

CRITICAL MOCKING NOTE: `editor.ts` imports `fs` via `import * as fs from 'fs/promises'` (WITHOUT the `node:` prefix). Therefore, `vi.mock` MUST target `'fs/promises'` (not `'node:fs/promises'`). The research incorrectly stated `node:fs/promises` for editor.ts.

Use this exact setup at file top:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { fs, vol } from 'memfs';

// editor.ts imports 'fs/promises' (no node: prefix)
vi.mock('fs/promises', () => ({ default: fs.promises, ...fs.promises }));

beforeEach(() => {
  vol.reset();
});
```

Because `vi.mock` is hoisted and the module gets re-resolved, use dynamic imports inside describe blocks or use `await import()` for the functions under test. This is the correct pattern when mocking fs:
```typescript
const { readFileValidated } = await import('../../src/core/editor.js');
```

**readFileValidated** (3-4 tests):
- File with valid UTF-8 content: `vol.fromJSON({ '/test/file.txt': 'hello world' })`, call readFileValidated('/test/file.txt'), expect 'hello world'
- Non-existent file: expect rejection/thrown error (ENOENT)
- For invalid UTF-8 testing: The `isUtf8` function from `buffer` module is NOT mocked by memfs. Since `vol.fromJSON` always creates valid UTF-8 strings, test the invalid path by mocking `buffer` module's `isUtf8` to return false:
  ```typescript
  vi.mock('buffer', async (importOriginal) => {
    const actual = await importOriginal();
    return { ...actual, isUtf8: () => false };
  });
  ```
  NOTE: If this approach causes conflicts with other tests, skip the invalid UTF-8 test and document why (memfs limitation). The happy path test is more important.

**atomicWrite** (3-4 tests):
- Successful write: `vol.mkdirSync('/test', { recursive: true })`, call atomicWrite('/test/file.txt', 'content'), verify file exists with correct content via `vol.readFileSync('/test/file.txt', 'utf8')`
- Verify atomic behavior: after atomicWrite, the file content is complete (not partial)
- Verify write to existing file overwrites: create file, atomicWrite with new content, verify new content

**createBackup** (3-4 tests -- currently 0% coverage):
- Successful backup: create file via `vol.fromJSON({ '/test/file.txt': 'original' })`, call `createBackup('/test/file.txt', 'original')`, verify '/test/file.txt.bak' exists with content 'original'
- Verify returned backup path is '{filePath}.bak'
- Verify backup preserves content accurately (compare original to backup content)
- For permission/chmod testing: memfs supports stat() and chmod() calls. Verify createBackup calls through without error. Do NOT assert specific mode values from memfs as they may not be reliable per research open question #1.

**applyEdits with IO** (3-4 tests):
- Full success path with memfs: create file, call applyEdits, verify file content changed
- Backup creation: verify .bak file exists after applyEdits with backup=true
- Dry-run with memfs: create file, call applyEdits with dryRun=true, verify file content unchanged
- backup=false: verify .bak file does NOT exist after applyEdits with backup=false
  </action>
  <verify>Run `npm test -- tests/unit/editor-io.test.ts` and confirm all tests pass.</verify>
  <done>memfs installed, editor-io.test.ts has 12+ passing tests. createBackup has direct coverage (previously 0%).</done>
</task>

<task type="auto">
  <name>Task 2: Validator async function tests with memfs</name>
  <files>tests/unit/validator-async.test.ts</files>
  <action>
Create `tests/unit/validator-async.test.ts` with filesystem-mocked tests for validator.ts async functions.

CRITICAL MOCKING NOTE: `validator.ts` imports `fs` via `import fs from 'node:fs/promises'` (WITH the `node:` prefix). Therefore, `vi.mock` MUST target `'node:fs/promises'`.

Use this exact setup at file top:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { fs, vol } from 'memfs';

// validator.ts imports 'node:fs/promises' (WITH node: prefix)
vi.mock('node:fs/promises', () => ({ default: fs.promises, ...fs.promises }));

beforeEach(() => {
  vol.reset();
});
```

Use dynamic imports for the functions under test (required because vi.mock needs to intercept before module loads):
```typescript
const { validateFileExists } = await import('../../src/core/validator.js');
```

**validateFileExists** (4-5 tests -- currently 0% coverage):
- Existing file: `vol.fromJSON({ '/test/file.txt': 'content' })`, returns object with `resolvedPath` property
- Non-existent file: returns ValidationError with code 'FILE_NOT_FOUND'
- Verify returned resolvedPath for existing file is '/test/file.txt' (memfs resolves to same path since no symlinks)
- Test that recovery_hint is defined on error responses
- For EACCES testing: This is hard to simulate with memfs. Skip or use vi.spyOn on fs.realpath to throw an EACCES error:
  ```typescript
  it('should return PERMISSION_DENIED for EACCES', async () => {
    const fsModule = await import('node:fs/promises');
    vi.spyOn(fsModule, 'realpath').mockRejectedValueOnce(
      Object.assign(new Error('EACCES'), { code: 'EACCES' })
    );
    const { validateFileExists } = await import('../../src/core/validator.js');
    const result = await validateFileExists('/test/no-access.txt');
    expect(result).toHaveProperty('code', 'PERMISSION_DENIED');
  });
  ```

**detectDuplicateFilePaths** (3-4 tests -- currently 0% coverage):
- No duplicates: `vol.fromJSON({ '/test/a.txt': 'a', '/test/b.txt': 'b' })`, returns empty array
- Duplicate paths (same string twice): create one file, pass it twice in array, returns error with code 'DUPLICATE_FILE_PATH'
- Mixed existing/non-existing: non-existing files are skipped for duplicate detection (per codebase decision), verify no crash
- Verify error path includes file index: ['files', '{index}', 'file_path']

**validateMultiEditInputFull** (5-6 tests -- currently 0% coverage):
- Layer 1 (Zod): pass invalid schema input (missing file_path), returns errors
- Layer 2 (path): pass relative path, returns RELATIVE_PATH error
- Layer 3 (duplicates): pass duplicate old_strings, returns DUPLICATE_OLD_STRING error
- Layer 4 (existence): create file in memfs, pass valid input, returns success with resolvedPath
- Full success: `vol.fromJSON({ '/test/file.ts': 'content' })`, valid input with absolute path and unique edits, returns `{ success: true, data: {...} }` with data.file_path set to resolved path
- Non-existent file: valid schema + absolute path + unique edits but file doesn't exist, returns FILE_NOT_FOUND

**validateMultiEditFilesInputFull** (5-6 tests -- currently 0% coverage):
- Layer 1 (Zod hard stop): pass `{ files: [] }`, returns SCHEMA_TOO_SMALL error
- Layer 2 (path per file): one file with relative path, returns error with path ['files', '0', 'file_path']
- Layer 4 (existence): files exist in memfs, returns success
- Layer 5 (per-file duplicate old_strings): file with duplicate old_strings in edits, returns DUPLICATE_OLD_STRING with file-prefixed path
- Full success: create 2 files in memfs, pass valid multi-file input, returns `{ success: true, data: {...} }` with resolved paths
- Error collection: pass input with BOTH a relative path (file 0) AND a non-existent file (file 1) -- verify BOTH errors are returned (not just the first), confirming layers 2-5 collect all errors

NOTE: If module re-import issues occur with vi.mock (tests see real fs instead of memfs), use `vi.resetModules()` in beforeEach alongside `vol.reset()`, and dynamically import the module in each test.
  </action>
  <verify>Run `npm test -- tests/unit/validator-async.test.ts` and confirm all tests pass.</verify>
  <done>validator-async.test.ts has 17+ passing tests. validateFileExists, detectDuplicateFilePaths, validateMultiEditInputFull, and validateMultiEditFilesInputFull all have direct coverage (previously 0%).</done>
</task>

</tasks>

<verification>
Run full test suite: `npm test`
All existing tests still pass (no regressions).
All new tests in editor-io.test.ts and validator-async.test.ts pass.
Run `npm test -- --coverage` and verify editor.ts and validator.ts coverage has improved significantly from baselines (editor.ts from ~91%, validator.ts from ~32%).
</verification>

<success_criteria>
- memfs is in devDependencies in package.json
- editor-io.test.ts exists with 12+ passing tests
- validator-async.test.ts exists with 17+ passing tests
- createBackup, validateFileExists, detectDuplicateFilePaths, validateMultiEditInputFull, validateMultiEditFilesInputFull all have direct test coverage
- `npm test` passes with zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/08-unit-testing/08-02-SUMMARY.md`
</output>
